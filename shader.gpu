

// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex, normal;
uniform mat4 ModelViewProjectionMatrix, NormalM;


varying vec3 varCol;

void main() {
    vec4 position4D = ModelViewProjectionMatrix * vec4(vertex, 1.0);
    vec3 position3D = vec3(position4D) / position4D.w;
    vec4 normalTransformed = NormalM * vec4(normal, 1.0);
    vec3 positionLight = vec3(1.0);
    vec3 normVec = normalize(vec3(normalTransformed));
    vec3 lightDir = normalize(positionLight - position3D);
    // Использование закона Ламберта
    float lambertEffect = max(dot(normVec, lightDir), 0.0);
    float specHighlight = 0.0;
    if(lambertEffect > 0.0) {
        vec3 reflectedLight = reflect(-lightDir, normVec);
        vec3 viewDir = normalize(-position3D);
        // Вычисление зеркального отражения
        float specularAngle = max(dot(reflectedLight, viewDir), 0.0);
        specHighlight = pow(specularAngle, 80.0);
    }
    vec3 ambientCol = vec3(0.0, 0.1, 0.0);
    vec3 diffuseCol = vec3(0.0, 0.7, 0.0);
    vec3 specularCol = vec3(0.0, 1.0, 0.0);
    varCol = vec3(ambientCol + lambertEffect * diffuseCol + specHighlight * specularCol);
    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
}`;



// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif
varying vec3 varCol;
uniform vec4 color;
void main() {
    gl_FragColor = color;
    gl_FragColor = vec4(varCol,1.0);
}`;